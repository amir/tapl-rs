use std::str::FromStr;

use tapl::fullsimple::ast::{Term, Type};
use tapl::fullsimple::fullsimple::{Command, Context, ContextTermResult, RunError};
use tapl::fullsimple::fullsimple::{add_name, name_to_index};

grammar;

pub Term2: Box<Term> = {
    "true" => Box::new(Term::True),
    "false" => Box::new(Term::False),
    "zero" => Box::new(Term::Zero),
    "succ(" <Term2> ")" => Box::new(Term::Succ(<>)),
    "pred(" <Term2> ")" => Box::new(Term::Pred(<>)),
    "iszero(" <Term2> ")" => Box::new(Term::IsZero(<>)),
    "if" <Term2> "then" <Term2> "else" <Term2> => Box::new(Term::If(<>)),
};

pub Term: ContextTermResult = {
    AppTerm,
    "lambda" <v:LCID> ":" <ty:Type> "." <t:Term> => Box::new(move |ctx: Context| -> Result<Term, RunError> {
        let nctx = add_name(ctx, v.clone());
        t(nctx).and_then(|t2| Ok(Term::Abs(v.clone(), ty.clone(), Box::new(t2))))
    }),
};

Type: Type = {
    "Nat" => Type::Nat,
    "Bool" => Type::Bool,
};

AppTerm: ContextTermResult = {
    PathTerm,
};

PathTerm: ContextTermResult = {
    <t:PathTerm> "." <v:LCID> => Box::new(move |ctx: Context| -> Result<Term, RunError> {
        t(ctx).and_then(|t2| Ok(Term::Projection(Box::new(t2), v.clone())))
    }),
    <t:PathTerm> "." <i:INTV> => Box::new(move |ctx: Context| -> Result<Term, RunError> {
        t(ctx).and_then(|t2| Ok(Term::Projection(Box::new(t2), i.to_string())))
    }),
    AscribeTerm,
};

AscribeTerm: ContextTermResult = {
    <t:ATerm> "as" <ty:Type> => Box::new(move |ctx: Context| -> Result<Term, RunError> {
        t(ctx).and_then(|t2| Ok(Term::Ascribe(Box::new(t2), ty.clone())))
    }),
    ATerm,
};

TermSeq: ContextTermResult = {
    Term,
    <t1:Term> ";" <ts:TermSeq> => Box::new(move |ctx: Context| -> Result<Term, RunError> {
        let u = String::from("_");

        t1(ctx.clone()).and_then(|et1| {
            let nctx = add_name(ctx.clone(), u.clone());
            ts(nctx).and_then(|ets| {
                Ok(Term::App(Box::new(Term::Abs(u, Type::Unit, Box::new(ets))), Box::new(et1)))
            })
        })
    }),
};

ATerm: ContextTermResult = {
    "(" <ts:TermSeq> ")" => ts,
    "true" => Box::new(move |_: Context| -> Result<Term, RunError> {
        Ok(Term::True)
    }),
    "false" => Box::new(move |_: Context| -> Result<Term, RunError> {
        Ok(Term::False)
    }),
    <v:LCID> => Box::new(move |ctx: Context| -> Result<Term, RunError> {
        match name_to_index(ctx.clone(), &v) {
            Ok(i) => Ok(Term::Var(i, ctx.len())),
            Err(e) => Err(RunError::ContextError(e)),
        }
    }),
    <i:INTV> => Box::new(move |ctx: Context| -> Result<Term, RunError> {
        fn f(n: i32) -> Term {
            match n {
                0 => Term::Zero,
                n => Term::Succ(Box::new(f(n-1))),
            }
        }
        Ok(f(i))
    }),
};

UCID: String = {
    r"[A-Z][a-zA-Z]*" => String::from(<>),
};

LCID: String = {
    r"[a-z][a-z]*" => String::from(<>),
};

INTV: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};
